{"version":3,"sources":["node_modules/@turf/helpers/index.js","node_modules/@turf/meta/index.js","node_modules/@turf/bbox/index.js","node_modules/@turf/invariant/index.js","node_modules/@turf/boolean-point-in-polygon/index.js","node_modules/@turf/boolean-point-on-line/index.js","node_modules/@turf/boolean-contains/index.js","js/consts.js","js/scripts.js"],"names":["sg_geojson","type","features","properties","geometry","coordinates","navHighlighter","sections","document","querySelectorAll","scrollY","getElementById","scrollTop","forEach","current","sectionHeight","offsetHeight","sectionTop","offsetTop","sectionId","getAttribute","elementClasses","querySelector","classList","add","remove","window","downloadResume","navigator","geolocation","getCurrentPosition","position","userLoc","coords","longitude","latitude","sg_polygon","click","addEventListener","body","style","setProperty","pageYOffset","innerHeight"],"mappings":"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","file":"scripts.62c8f7ec.js","sourceRoot":"..","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar helpers = require('@turf/helpers');\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n    // Handles null Geometry -- Skips this GeoJSON\n    if (geojson === null) return;\n    var j, k, l, geometry, stopG, coords,\n        geometryMaybeCollection,\n        wrapShrink = 0,\n        coordIndex = 0,\n        isGeometryCollection,\n        type = geojson.type,\n        isFeatureCollection = type === 'FeatureCollection',\n        isFeature = type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n            var multiFeatureIndex = 0;\n            var geometryIndex = 0;\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;\n\n            // Handles null Geometry -- Skips this geometry\n            if (geometry === null) continue;\n            coords = geometry.coordinates;\n            var geomType = geometry.type;\n\n            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;\n\n            switch (geomType) {\n            case null:\n                break;\n            case 'Point':\n                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                coordIndex++;\n                multiFeatureIndex++;\n                break;\n            case 'LineString':\n            case 'MultiPoint':\n                for (j = 0; j < coords.length; j++) {\n                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                    coordIndex++;\n                    if (geomType === 'MultiPoint') multiFeatureIndex++;\n                }\n                if (geomType === 'LineString') multiFeatureIndex++;\n                break;\n            case 'Polygon':\n            case 'MultiLineString':\n                for (j = 0; j < coords.length; j++) {\n                    for (k = 0; k < coords[j].length - wrapShrink; k++) {\n                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                        coordIndex++;\n                    }\n                    if (geomType === 'MultiLineString') multiFeatureIndex++;\n                    if (geomType === 'Polygon') geometryIndex++;\n                }\n                if (geomType === 'Polygon') multiFeatureIndex++;\n                break;\n            case 'MultiPolygon':\n                for (j = 0; j < coords.length; j++) {\n                    geometryIndex = 0;\n                    for (k = 0; k < coords[j].length; k++) {\n                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n                            coordIndex++;\n                        }\n                        geometryIndex++;\n                    }\n                    multiFeatureIndex++;\n                }\n                break;\n            case 'GeometryCollection':\n                for (j = 0; j < geometry.geometries.length; j++)\n                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;\n                break;\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n    }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n    var previousValue = initialValue;\n    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;\n        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);\n    }, excludeWrapCoord);\n    return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n    var i;\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        for (i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i].properties, i) === false) break;\n        }\n        break;\n    case 'Feature':\n        callback(geojson.properties, 0);\n        break;\n    }\n}\n\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    propEach(geojson, function (currentProperties, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;\n        else previousValue = callback(previousValue, currentProperties, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n    if (geojson.type === 'Feature') {\n        callback(geojson, 0);\n    } else if (geojson.type === 'FeatureCollection') {\n        for (var i = 0; i < geojson.features.length; i++) {\n            if (callback(geojson.features[i], i) === false) break;\n        }\n    }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    featureEach(geojson, function (currentFeature, featureIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n    var coords = [];\n    coordEach(geojson, function (coord) {\n        coords.push(coord);\n    });\n    return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n    var i, j, g, geometry, stopG,\n        geometryMaybeCollection,\n        isGeometryCollection,\n        featureProperties,\n        featureBBox,\n        featureId,\n        featureIndex = 0,\n        isFeatureCollection = geojson.type === 'FeatureCollection',\n        isFeature = geojson.type === 'Feature',\n        stop = isFeatureCollection ? geojson.features.length : 1;\n\n    // This logic may look a little weird. The reason why it is that way\n    // is because it's trying to be fast. GeoJSON supports multiple kinds\n    // of objects at its root: FeatureCollection, Features, Geometries.\n    // This function has the responsibility of handling all of them, and that\n    // means that some of the `for` loops you see below actually just don't apply\n    // to certain inputs. For instance, if you give this just a\n    // Point geometry, then both loops are short-circuited and all we do\n    // is gradually rename the input until it's called 'geometry'.\n    //\n    // This also aims to allocate as few resources as possible: just a\n    // few numbers and booleans, rather than any temporary arrays as would\n    // be required with the normalization approach.\n    for (i = 0; i < stop; i++) {\n\n        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :\n            (isFeature ? geojson.geometry : geojson));\n        featureProperties = (isFeatureCollection ? geojson.features[i].properties :\n            (isFeature ? geojson.properties : {}));\n        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :\n            (isFeature ? geojson.bbox : undefined));\n        featureId = (isFeatureCollection ? geojson.features[i].id :\n            (isFeature ? geojson.id : undefined));\n        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;\n        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;\n\n        for (g = 0; g < stopG; g++) {\n            geometry = isGeometryCollection ?\n                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;\n\n            // Handle null Geometry\n            if (geometry === null) {\n                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                continue;\n            }\n            switch (geometry.type) {\n            case 'Point':\n            case 'LineString':\n            case 'MultiPoint':\n            case 'Polygon':\n            case 'MultiLineString':\n            case 'MultiPolygon': {\n                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                break;\n            }\n            case 'GeometryCollection': {\n                for (j = 0; j < geometry.geometries.length; j++) {\n                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;\n                }\n                break;\n            }\n            default:\n                throw new Error('Unknown Geometry Type');\n            }\n        }\n        // Only increase `featureIndex` per each feature\n        featureIndex++;\n    }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;\n        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n        // Callback for single geometry\n        var type = (geometry === null) ? null : geometry.type;\n        switch (type) {\n        case null:\n        case 'Point':\n        case 'LineString':\n        case 'Polygon':\n            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;\n            return;\n        }\n\n        var geomType;\n\n        // Callback for multi-geometry\n        switch (type) {\n        case 'MultiPoint':\n            geomType = 'Point';\n            break;\n        case 'MultiLineString':\n            geomType = 'LineString';\n            break;\n        case 'MultiPolygon':\n            geomType = 'Polygon';\n            break;\n        }\n\n        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {\n            var coordinate = geometry.coordinates[multiFeatureIndex];\n            var geom = {\n                type: geomType,\n                coordinates: coordinate\n            };\n            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;\n        }\n    });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {\n        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;\n        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        var segmentIndex = 0;\n\n        // Exclude null Geometries\n        if (!feature.geometry) return;\n        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n        var type = feature.geometry.type;\n        if (type === 'Point' || type === 'MultiPoint') return;\n\n        // Generate 2-vertex line segments\n        var previousCoords;\n        var previousFeatureIndex = 0;\n        var previousMultiIndex = 0;\n        var prevGeomIndex = 0;\n        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {\n            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {\n                previousCoords = currentCoord;\n                previousFeatureIndex = featureIndex;\n                previousMultiIndex = multiPartIndexCoord;\n                prevGeomIndex = geometryIndex;\n                segmentIndex = 0;\n                return;\n            }\n            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);\n            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;\n            segmentIndex++;\n            previousCoords = currentCoord;\n        }) === false) return false;\n    });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentInex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    var started = false;\n    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n        if (started === false && initialValue === undefined) previousValue = currentSegment;\n        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);\n        started = true;\n    });\n    return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n    // validation\n    if (!geojson) throw new Error('geojson is required');\n\n    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n        if (feature.geometry === null) return;\n        var type = feature.geometry.type;\n        var coords = feature.geometry.coordinates;\n        switch (type) {\n        case 'LineString':\n            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;\n            break;\n        case 'Polygon':\n            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {\n                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;\n            }\n            break;\n        }\n    });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n    var previousValue = initialValue;\n    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;\n        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);\n    });\n    return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var segmentIndex = options.segmentIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find SegmentIndex\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n    // Optional Parameters\n    options = options || {};\n    if (!helpers.isObject(options)) throw new Error('options is invalid');\n    var featureIndex = options.featureIndex || 0;\n    var multiFeatureIndex = options.multiFeatureIndex || 0;\n    var geometryIndex = options.geometryIndex || 0;\n    var coordIndex = options.coordIndex || 0;\n\n    // Find FeatureIndex\n    var properties = options.properties;\n    var geometry;\n\n    switch (geojson.type) {\n    case 'FeatureCollection':\n        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;\n        properties = properties || geojson.features[featureIndex].properties;\n        geometry = geojson.features[featureIndex].geometry;\n        break;\n    case 'Feature':\n        properties = properties || geojson.properties;\n        geometry = geojson.geometry;\n        break;\n    case 'Point':\n    case 'MultiPoint':\n        return null;\n    case 'LineString':\n    case 'Polygon':\n    case 'MultiLineString':\n    case 'MultiPolygon':\n        geometry = geojson;\n        break;\n    default:\n        throw new Error('geojson is invalid');\n    }\n\n    // Find Coord Index\n    if (geometry === null) return null;\n    var coords = geometry.coordinates;\n    switch (geometry.type) {\n    case 'Point':\n        return helpers.point(coords, properties, options);\n    case 'MultiPoint':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        return helpers.point(coords[multiFeatureIndex], properties, options);\n    case 'LineString':\n        if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n        return helpers.point(coords[coordIndex], properties, options);\n    case 'Polygon':\n        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;\n        return helpers.point(coords[geometryIndex][coordIndex], properties, options);\n    case 'MultiLineString':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;\n        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case 'MultiPolygon':\n        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;\n        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);\n    }\n    throw new Error('geojson is invalid');\n}\n\nexports.coordEach = coordEach;\nexports.coordReduce = coordReduce;\nexports.propEach = propEach;\nexports.propReduce = propReduce;\nexports.featureEach = featureEach;\nexports.featureReduce = featureReduce;\nexports.coordAll = coordAll;\nexports.geomEach = geomEach;\nexports.geomReduce = geomReduce;\nexports.flattenEach = flattenEach;\nexports.flattenReduce = flattenReduce;\nexports.segmentEach = segmentEach;\nexports.segmentReduce = segmentReduce;\nexports.lineEach = lineEach;\nexports.lineReduce = lineReduce;\nexports.findSegment = findSegment;\nexports.findPoint = findPoint;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar meta_1 = require(\"@turf/meta\");\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    meta_1.coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nexports.default = bbox;\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"@turf/helpers\");\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = require(\"@turf/invariant\");\n// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule\n// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js\n// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n/**\n * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point\n * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.\n *\n * @name booleanPointInPolygon\n * @param {Coord} point input point\n * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if\n * the point is inside the polygon otherwise false.\n * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon\n * @example\n * var pt = turf.point([-77, 44]);\n * var poly = turf.polygon([[\n *   [-81, 41],\n *   [-81, 47],\n *   [-72, 47],\n *   [-72, 41],\n *   [-81, 41]\n * ]]);\n *\n * turf.booleanPointInPolygon(pt, poly);\n * //= true\n */\nfunction booleanPointInPolygon(point, polygon, options) {\n    if (options === void 0) { options = {}; }\n    // validation\n    if (!point) {\n        throw new Error(\"point is required\");\n    }\n    if (!polygon) {\n        throw new Error(\"polygon is required\");\n    }\n    var pt = invariant_1.getCoord(point);\n    var geom = invariant_1.getGeom(polygon);\n    var type = geom.type;\n    var bbox = polygon.bbox;\n    var polys = geom.coordinates;\n    // Quick elimination if point is not inside bbox\n    if (bbox && inBBox(pt, bbox) === false) {\n        return false;\n    }\n    // normalize to multipolygon\n    if (type === \"Polygon\") {\n        polys = [polys];\n    }\n    var insidePoly = false;\n    for (var i = 0; i < polys.length && !insidePoly; i++) {\n        // check if it is in the outer ring first\n        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {\n            var inHole = false;\n            var k = 1;\n            // check for the point in any of the holes\n            while (k < polys[i].length && !inHole) {\n                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {\n                    inHole = true;\n                }\n                k++;\n            }\n            if (!inHole) {\n                insidePoly = true;\n            }\n        }\n    }\n    return insidePoly;\n}\nexports.default = booleanPointInPolygon;\n/**\n * inRing\n *\n * @private\n * @param {Array<number>} pt [x,y]\n * @param {Array<Array<number>>} ring [[x,y], [x,y],..]\n * @param {boolean} ignoreBoundary ignoreBoundary\n * @returns {boolean} inRing\n */\nfunction inRing(pt, ring, ignoreBoundary) {\n    var isInside = false;\n    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {\n        ring = ring.slice(0, ring.length - 1);\n    }\n    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {\n        var xi = ring[i][0];\n        var yi = ring[i][1];\n        var xj = ring[j][0];\n        var yj = ring[j][1];\n        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&\n            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);\n        if (onBoundary) {\n            return !ignoreBoundary;\n        }\n        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&\n            (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);\n        if (intersect) {\n            isInside = !isInside;\n        }\n    }\n    return isInside;\n}\n/**\n * inBBox\n *\n * @private\n * @param {Position} pt point [x,y]\n * @param {BBox} bbox BBox [west, south, east, north]\n * @returns {boolean} true/false if point is inside BBox\n */\nfunction inBBox(pt, bbox) {\n    return bbox[0] <= pt[0] &&\n        bbox[1] <= pt[1] &&\n        bbox[2] >= pt[0] &&\n        bbox[3] >= pt[1];\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Returns true if a point is on a line. Accepts a optional parameter to ignore the\n * start and end vertices of the linestring.\n *\n * @name booleanPointOnLine\n * @param {Coord} pt GeoJSON Point\n * @param {Feature<LineString>} line GeoJSON LineString\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.\n * @returns {boolean} true/false\n * @example\n * var pt = turf.point([0, 0]);\n * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);\n * var isPointOnLine = turf.booleanPointOnLine(pt, line);\n * //=true\n */\nfunction booleanPointOnLine(pt, line, options) {\n    if (options === void 0) { options = {}; }\n    // Normalize inputs\n    var ptCoords = invariant_1.getCoord(pt);\n    var lineCoords = invariant_1.getCoords(line);\n    // Main\n    for (var i = 0; i < lineCoords.length - 1; i++) {\n        var ignoreBoundary = false;\n        if (options.ignoreEndVertices) {\n            if (i === 0) {\n                ignoreBoundary = \"start\";\n            }\n            if (i === lineCoords.length - 2) {\n                ignoreBoundary = \"end\";\n            }\n            if (i === 0 && i + 1 === lineCoords.length - 1) {\n                ignoreBoundary = \"both\";\n            }\n        }\n        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary)) {\n            return true;\n        }\n    }\n    return false;\n}\n// See http://stackoverflow.com/a/4833823/1979085\n/**\n * @private\n * @param {Position} lineSegmentStart coord pair of start of line\n * @param {Position} lineSegmentEnd coord pair of end of line\n * @param {Position} pt coord pair of point to check\n * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.\n * If true which end to ignore.\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary) {\n    var x = pt[0];\n    var y = pt[1];\n    var x1 = lineSegmentStart[0];\n    var y1 = lineSegmentStart[1];\n    var x2 = lineSegmentEnd[0];\n    var y2 = lineSegmentEnd[1];\n    var dxc = pt[0] - x1;\n    var dyc = pt[1] - y1;\n    var dxl = x2 - x1;\n    var dyl = y2 - y1;\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0) {\n        return false;\n    }\n    if (!excludeBoundary) {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;\n    }\n    else if (excludeBoundary === \"start\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;\n    }\n    else if (excludeBoundary === \"end\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;\n        }\n        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;\n    }\n    else if (excludeBoundary === \"both\") {\n        if (Math.abs(dxl) >= Math.abs(dyl)) {\n            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;\n        }\n        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;\n    }\n    return false;\n}\nexports.default = booleanPointOnLine;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar bbox_1 = __importDefault(require(\"@turf/bbox\"));\nvar boolean_point_in_polygon_1 = __importDefault(require(\"@turf/boolean-point-in-polygon\"));\nvar boolean_point_on_line_1 = __importDefault(require(\"@turf/boolean-point-on-line\"));\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Boolean-contains returns True if the second geometry is completely contained by the first geometry.\n * The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b)\n * must not intersect the exterior of the primary (geometry a).\n * Boolean-contains returns the exact opposite result of the `@turf/boolean-within`.\n *\n * @name booleanContains\n * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry\n * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry\n * @returns {boolean} true/false\n * @example\n * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);\n * var point = turf.point([1, 2]);\n *\n * turf.booleanContains(line, point);\n * //=true\n */\nfunction booleanContains(feature1, feature2) {\n    var geom1 = invariant_1.getGeom(feature1);\n    var geom2 = invariant_1.getGeom(feature2);\n    var type1 = invariant_1.getType(feature1);\n    var type2 = invariant_1.getType(feature2);\n    var coords1 = invariant_1.getCoords(feature1);\n    var coords2 = invariant_1.getCoords(feature2);\n    switch (type1) {\n        case \"Point\":\n            switch (type2) {\n                case \"Point\":\n                    return compareCoords(coords1, coords2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"MultiPoint\":\n            switch (type2) {\n                case \"Point\":\n                    return isPointInMultiPoint(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointInMultiPoint(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"LineString\":\n            switch (type2) {\n                case \"Point\":\n                    return boolean_point_on_line_1.default(geom2, geom1, { ignoreEndVertices: true });\n                case \"LineString\":\n                    return isLineOnLine(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointOnLine(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        case \"Polygon\":\n            switch (type2) {\n                case \"Point\":\n                    return boolean_point_in_polygon_1.default(geom2, geom1, { ignoreBoundary: true });\n                case \"LineString\":\n                    return isLineInPoly(geom1, geom2);\n                case \"Polygon\":\n                    return isPolyInPoly(geom1, geom2);\n                case \"MultiPoint\":\n                    return isMultiPointInPoly(geom1, geom2);\n                default:\n                    throw new Error(\"feature2 \" + type2 + \" geometry not supported\");\n            }\n        default:\n            throw new Error(\"feature1 \" + type1 + \" geometry not supported\");\n    }\n}\nexports.default = booleanContains;\nfunction isPointInMultiPoint(multiPoint, pt) {\n    var i;\n    var output = false;\n    for (i = 0; i < multiPoint.coordinates.length; i++) {\n        if (compareCoords(multiPoint.coordinates[i], pt.coordinates)) {\n            output = true;\n            break;\n        }\n    }\n    return output;\n}\nexports.isPointInMultiPoint = isPointInMultiPoint;\nfunction isMultiPointInMultiPoint(multiPoint1, multiPoint2) {\n    for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {\n        var coord2 = _a[_i];\n        var matchFound = false;\n        for (var _b = 0, _c = multiPoint1.coordinates; _b < _c.length; _b++) {\n            var coord1 = _c[_b];\n            if (compareCoords(coord2, coord1)) {\n                matchFound = true;\n                break;\n            }\n        }\n        if (!matchFound) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isMultiPointInMultiPoint = isMultiPointInMultiPoint;\nfunction isMultiPointOnLine(lineString, multiPoint) {\n    var haveFoundInteriorPoint = false;\n    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (boolean_point_on_line_1.default(coord, lineString, { ignoreEndVertices: true })) {\n            haveFoundInteriorPoint = true;\n        }\n        if (!boolean_point_on_line_1.default(coord, lineString)) {\n            return false;\n        }\n    }\n    if (haveFoundInteriorPoint) {\n        return true;\n    }\n    return false;\n}\nexports.isMultiPointOnLine = isMultiPointOnLine;\nfunction isMultiPointInPoly(polygon, multiPoint) {\n    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {\n        var coord = _a[_i];\n        if (!boolean_point_in_polygon_1.default(coord, polygon, { ignoreBoundary: true })) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isMultiPointInPoly = isMultiPointInPoly;\nfunction isLineOnLine(lineString1, lineString2) {\n    var haveFoundInteriorPoint = false;\n    for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {\n        var coords = _a[_i];\n        if (boolean_point_on_line_1.default({ type: \"Point\", coordinates: coords }, lineString1, { ignoreEndVertices: true })) {\n            haveFoundInteriorPoint = true;\n        }\n        if (!boolean_point_on_line_1.default({ type: \"Point\", coordinates: coords }, lineString1, { ignoreEndVertices: false })) {\n            return false;\n        }\n    }\n    return haveFoundInteriorPoint;\n}\nexports.isLineOnLine = isLineOnLine;\nfunction isLineInPoly(polygon, linestring) {\n    var output = false;\n    var i = 0;\n    var polyBbox = bbox_1.default(polygon);\n    var lineBbox = bbox_1.default(linestring);\n    if (!doBBoxOverlap(polyBbox, lineBbox)) {\n        return false;\n    }\n    for (i; i < linestring.coordinates.length - 1; i++) {\n        var midPoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);\n        if (boolean_point_in_polygon_1.default({ type: \"Point\", coordinates: midPoint }, polygon, { ignoreBoundary: true })) {\n            output = true;\n            break;\n        }\n    }\n    return output;\n}\nexports.isLineInPoly = isLineInPoly;\n/**\n * Is Polygon2 in Polygon1\n * Only takes into account outer rings\n *\n * @private\n * @param {Geometry|Feature<Polygon>} feature1 Polygon1\n * @param {Geometry|Feature<Polygon>} feature2 Polygon2\n * @returns {boolean} true/false\n */\nfunction isPolyInPoly(feature1, feature2) {\n    // Handle Nulls\n    if (feature1.type === \"Feature\" && feature1.geometry === null) {\n        return false;\n    }\n    if (feature2.type === \"Feature\" && feature2.geometry === null) {\n        return false;\n    }\n    var poly1Bbox = bbox_1.default(feature1);\n    var poly2Bbox = bbox_1.default(feature2);\n    if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {\n        return false;\n    }\n    var coords = invariant_1.getGeom(feature2).coordinates;\n    for (var _i = 0, coords_1 = coords; _i < coords_1.length; _i++) {\n        var ring = coords_1[_i];\n        for (var _a = 0, ring_1 = ring; _a < ring_1.length; _a++) {\n            var coord = ring_1[_a];\n            if (!boolean_point_in_polygon_1.default(coord, feature1)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nexports.isPolyInPoly = isPolyInPoly;\nfunction doBBoxOverlap(bbox1, bbox2) {\n    if (bbox1[0] > bbox2[0]) {\n        return false;\n    }\n    if (bbox1[2] < bbox2[2]) {\n        return false;\n    }\n    if (bbox1[1] > bbox2[1]) {\n        return false;\n    }\n    if (bbox1[3] < bbox2[3]) {\n        return false;\n    }\n    return true;\n}\nexports.doBBoxOverlap = doBBoxOverlap;\n/**\n * compareCoords\n *\n * @private\n * @param {Position} pair1 point [x,y]\n * @param {Position} pair2 point [x,y]\n * @returns {boolean} true/false if coord pairs match\n */\nfunction compareCoords(pair1, pair2) {\n    return pair1[0] === pair2[0] && pair1[1] === pair2[1];\n}\nexports.compareCoords = compareCoords;\nfunction getMidpoint(pair1, pair2) {\n    return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];\n}\nexports.getMidpoint = getMidpoint;\n","export const sg_geojson = {\n  type: \"FeatureCollection\",\n  features: [\n    {\n      type: \"Feature\",\n      properties: {},\n      geometry: {\n        type: \"Polygon\",\n        coordinates: [\n          [\n            [103.59489440917969, 1.2715630876314767],\n            [103.59077453613281, 1.2296876901489255],\n            [103.58940124511719, 1.1987955811436186],\n            [103.61618041992188, 1.1658436142465605],\n            [103.64639282226562, 1.1356373055193174],\n            [103.6834716796875, 1.1438754213781501],\n            [103.73291015625, 1.1541730329228161],\n            [103.77960205078125, 1.176141145843977],\n            [103.85581970214844, 1.2029145493452873],\n            [103.87195587158203, 1.2386120110295982],\n            [103.89083862304688, 1.2712198493992468],\n            [103.97666931152344, 1.2887249407943617],\n            [104.02713775634766, 1.3038272759700005],\n            [104.09065246582031, 1.334718132769963],\n            [104.08035278320312, 1.3498201887565244],\n            [104.08721923828125, 1.3807104645408492],\n            [104.09271240234374, 1.4006173190275208],\n            [104.07829284667969, 1.4308204986633148],\n            [104.04945373535156, 1.4466083666436405],\n            [104.0185546875, 1.4445490857204621],\n            [103.99658203125, 1.425329040790274],\n            [103.941650390625, 1.4294476354255539],\n            [103.90731811523438, 1.4267019064882447],\n            [103.87298583984375, 1.4514133481911609],\n            [103.83316040039062, 1.474065265973824],\n            [103.79745483398438, 1.4754381021049132],\n            [103.75419616699219, 1.4493540716333067],\n            [103.71299743652344, 1.4555318956783565],\n            [103.67523193359375, 1.435625513519856],\n            [103.65463256835938, 1.4019901993378632],\n            [103.59489440917969, 1.2715630876314767],\n          ],\n        ],\n      },\n    },\n  ],\n};\n\nexport const navHighlighter = () => {\n  const sections = document.querySelectorAll(\"section[id]\");\n  // Get current scroll position\n  let scrollY = document.getElementById(\"scroll-container\").scrollTop;\n  // Now we loop through sections to get height, top and ID values for each\n  sections.forEach(current => {\n    const sectionHeight = current.offsetHeight;\n    const sectionTop = current.offsetTop - 50;\n    const sectionId = current.getAttribute(\"id\");\n    const elementClasses = document.querySelector(\".nav a[href*=\" + sectionId + \"]\").classList;\n\n    /*\n    - If our current scroll position enters the space where current section on screen is, add .active class to corresponding navigation link, else remove it\n    - To know which link needs an active class, we use sectionId variable we are getting while looping through sections as an selector\n    */\n    if (\n      scrollY > sectionTop &&\n      scrollY <= sectionTop + sectionHeight\n    ){\n      elementClasses.add(\"active-light\");\n    } else {\n      elementClasses.remove(\"active-light\");\n    }\n  });\n}","import booleanContains from \"@turf/boolean-contains\";\nimport { point, polygon } from \"@turf/helpers\";\nimport { sg_geojson, navHighlighter } from \"./consts\";\n\nwindow.downloadResume = function () {\n  if (navigator.geolocation) {\n    navigator.geolocation.getCurrentPosition(\n      (position) => {\n        const userLoc = point([\n          position.coords.longitude,\n          position.coords.latitude,\n        ]);\n        const sg_polygon = polygon(sg_geojson.features[0].geometry.coordinates);\n        if (booleanContains(sg_polygon, userLoc)) {\n          document.getElementById(\"download-local\").click();\n        } else {\n          document.getElementById(\"download-resume\").click();\n        }\n      },\n      () => {\n        document.getElementById(\"download-resume\").click();\n      }\n    );\n  } else {\n    document.getElementById(\"download-resume\").click();\n  }\n};\n\nwindow.addEventListener('scroll', () => {\n  document.body.style.setProperty('--scroll',window.pageYOffset / (document.body.offsetHeight - window.innerHeight));\n}, false);\n\n// Add an event listener listening for scroll\ndocument.getElementById(\"scroll-container\").addEventListener(\"scroll\", navHighlighter);\n"]}